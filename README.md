### Hi 👋
我是王帅东，是一名大学生，目前就读于[淄博职业学院](https://www.zbvc.edu.cn/)，同时也是一名计算机爱好者。  
目前正在学习**JAVA**，**C#**，**Python**，**PS**，**PR**，**DW**，虽然现在还不够熟练，但我相信在  
后天的努力下我也会成为一名精通各种语言与软件的秃头带师^_^。  
如果你想要联系我，  
我的邮箱是**2372816590@qq.com**，也可以加我的QQ**2372816590**.  
这是我的个人情况。欢迎各位叨扰==  
  
  
  
  
当初决定学习计算机是认为自己在计算机上还算是比较有天赋，也感兴趣，愿意为学习计算机付出时间和心血，而且家中也有亲  
人从事这方面的情况，所以决定学习计算机。目前我认为在我实际接触这方面后与我在还处于一个小白时期的期待是比较相符的  
因为我其实之前是有过一段时间的计算机学习经历的，所以在这方面觉得自己还是能够做出一个比较清晰的认知的，所以我认为  
自己的预计还是较为准确的。就目前来看我并不讨厌计算机，但是要说喜欢嘛，吼吼~真正开始学习以后被虐过多次我也只能把它  
当初恋一般的对待的，而且我认为我对这方面理解力还是不错的，就喜爱程度而言我觉得我初心未改，另外关于这方面的擅长与否  
老实说我觉得我还不能说对这方面擅长，但是我还是有自信可以学好这方面的知识，因为我愿意付出，也愿意花时间，我认为任何  
事能够做到这两点不愁大事不成。  
  
>自我评估
- 我所具备的
  1. 已掌握的专业知识：**JAVA**,**DW**
  2. 已了解的相关学习平台：**CSDN**，相关视频（[B站](https://www.bilibili.com/)大会员已充值^_^）
- 我所缺陷的
  1. 专业知识储备不足
  2. 专业知识练习不够，不够熟练
- 我希望自己将来具备的
  1.更加完善的知识储备，做到不仅是会，更懂
  2.更加熟练的技能运用，做到制作一个程序完全不需要基本语法还要查一查确定
  
之前做过一次JAVA的大作业，内容搭建一个平台，实现与MySQL的连接，并做到其中的数据可修改并实时将数据存入MySQL中，当时就
对这类实现数据的对接方面感觉极为感兴趣，还有目前在学的**android studio**都非常感兴趣，希望以后可以精通这方面相关知识。
  
我希望能够在此课程中对软件这个宏观的概念有更加具体的了解，以及以后作为一名软件工程师自己应该具备什么样的能力还有在这方  
面做项目时的注意事项。
  
心得：我认为上课听讲是必要的，因为上课我们不仅仅是在学习知识，更是对自己心性的历练，古人云：**学习有法，而无定法，贵在得法。**  
因此我们不仅仅是在学习如果对老师所讲并无兴趣，才更加应该认真听讲，自古能者皆谦逊克己，所以总结来说就是一句话：**老师说的太对了！^_^！**

>**单元测试**  
  
**第一题：**  
1.帮助开发人员编写代码，提升质量、减少bug。如果大家分析一下我们bug原因的构成，我想有会有一部分bug的原因是开发人员在编写工作代  
码的时候没有考虑到某些case或者边际条件。造成这种问题的原因很多，其中很重要的一个原因是我们对工作代码所要完成的功能思考不足，而  
编写单元测试，特别是先写单元测试再写工作代码就可以帮助开发人员思考编写的代码到底要实现哪些功能。例如实现一个简单的用户注册功能  
的业务类方法，用单元测试再写工作代码的方式来工作的话开发人员就会先考虑各种场景相关，例如正常注册、用户名重复、没有满足必要的填  
写内容......等等，之后就会编写相关的测试用例编写单元测试代码的过程就是促使开发人员思考工作代码实现内容和逻辑的过程，之后实现工  
作代码的时候，开发人员思路会更清晰，实现代码的质量也会有相应的提升。  
2. 提升反馈速度，减少重复工作，提高开发效率。开发人员实现某个功能或者修补了某个bug，如果有相应的单元测试支持的话，开发人员可以  
马上通过运行单元测试来验证之前完成的代码是否正确，而不需要反复通过发布war包、启动jboss、通过浏览器输入数据等繁琐的步骤来验证所  
完成的功能。用单元测试代码来验证代码和通过发布应用以人工的方式来验证代码这两者的效率差很多，看到很多开发人员每天要反复执行N次发  
布脚本（antx之类的工具）真是痛苦。  
3.保证你最后的代码修改不会破坏之前代码的功能。项目越做越大，代码越来越多，特别涉及到一些公用接口之类的代码或是底层的基础库，谁也  
不敢保证这次修改的代码不会破坏之前的功能，所以与此相关的需求会被搁置或推迟，由于不敢改进代码，代码也变得越来越难以维护，质量也越  
来越差。而单元测试就是解决这种问题的很好方法（不敢说最好的）。由于代码的历史功能都有相应的单元测试保证，修改了某些代码以后，通过  
运行相关的单元测试就可以验证出新调整的功能是否有影响到之前的功能。当然要实现到这种程度需要很大的付出，不但要能够达到比较高的测试  
覆盖率，而且单元测试代码的编写质量也要有保证。  
4. 让代码维护更容易。由于给代码写很多单元测试，相当于给代码加上了规格说明书，开发人员通过读单元测试代码也能够帮助开发人员理解现有  
代码。很有opensource的项目都有相当量的单元测试代码，通过读这些测试代码会有助于理解生产源代码。  
5. 有助于改进代码质量和设计。除了那些大拿们编写的代码，我相信很多易于维护、设计良好的代码都是通过不断的重构才得到的。虽然说单元测  
试本身不能直接改进生产代码的质量，但它为生产代码提供了"安全网"，让开发人员可以勇敢地改进代码，从而让代码的clean和beautiful不再是  
梦想。
  
**第二题：**  
public class Main extends Object {  
    public static void main(String[]args) {  
        int[] data = {6,5,9,7,2,8};  
        System.out.println("冒泡排序法： ");  
        System.out.println("原始数据为： ");  
        for(int i = 0; i < data.length; i++) {  
            System.out.print(data[i] + " ");  
        }  
        System.out.print("\n");  
        bubbleSort(data);  
    }  
    public static void bubbleSort(int[]data) {  
        int temp;  
        for(int i = data.length - 1; i > 0; i--) {  
            for(int j = 0; j < i; j++) {  
                if(data[j] > data[j + 1]) {  
                    temp = data[j];  
                    data[j] = data[j + 1];  
                    data[j + 1] = temp;  
                }  
            }  
            System.out.print("第" + (data.length - i) +"次排序结果为： ");  
            for(int k = 0; k < data.length; k++) {  
                System.out.print(data[k] + " ");  
            }  
            System.out.print("\n");  
        }  
    }  
}  
  
冒泡排序法：  
原始数据为：  
**6 5 9 7 2 8**  
第1次排序结果为： **5 6 7 2 8 9**  
第2次排序结果为： **5 6 2 7 8 9**  
第3次排序结果为： **5 2 6 7 8 9**  
第4次排序结果为： **2 5 6 7 8 9**  
第5次排序结果为： **2 5 6 7 8 9**  
  
  
>**耗时八小时倾情巨献，老师给个好评哦^_^**
